aditya@ubuntu:~$ javac simp11/spos.java
aditya@ubuntu:~$ javac simp11/pooltable.java
aditya@ubuntu:~$ javac simp11/obj.java
aditya@ubuntu:~$ java simp11.spos

*************************************SYMBOL TABLE*************************************

SYMBOL	ADDRESS
up	102
a	111
b	110
c	0
next	102

*************************************POOL TABLE*************************************

POOL	TOTAL LITERALS
1	1
2	2
4	2

*************************************LITERAL TABLE*************************************

Index	LITERAL	ADDRESS
1	='5'	102
2	='8'	105
3	='8'	106
4	='7'	114
5	='8'	115

*************************************OPTABLE*************************************

MNEMONIC	OPCODE
mover		0
mover		0
add		2
movem		1
mul		5
movem		1
movem		1
movem		1
movem		1
ds		0
dc		1
ds		0

***********************Output1.txt***********************

	(AD,1)	(C,100)
100	(IS,1)	(1)	(C,05)
101	(IS,1)	(2)	(C,10)
102	(S,1)	(IS,3)	(1)	(2)
103	(IS,2)	(S,2)	(L,1)
104	(IS,6)	(1)	(S,1)
105	(AD,3)	(S,1)
102	(DL,1)	(L,1)
103	(IS,2)	(S,3)	(L,2)
104	(IS,2)	(S,4)	(L,3)
105	(DL,1)	(L,2)
106	(DL,1)	(L,3)
107	(IS,2)	(S,2)	(L,4)
108	(IS,2)	(S,3)	(L,5)
109	(DL,1)	(C,02)
110	(DL,2)	(C,10)
111	(DL,1)	(C,09)
112	(S,5)	(AD,5)	(S,1)
113	(AD,2)


In the given Java code, `sample.txt` is the input file containing the sample assembly code that the program processes. `Output1.txt` is the output file where the processed assembly instructions, symbols, literals, and other information are written in a formatted manner.

Here's why these input and output files are used:

### `sample.txt` (Input File):
- **Purpose:** It serves as the source of input for the assembler program. The program reads the assembly instructions, symbols, literals, and directives from this file.
- **Content:** Contains the assembly code that the program processes, including various assembly instructions, symbols, literals, and directives (`start`, `end`, `origin`, `ltorg`, `equ`).

### `Output1.txt` (Output File):
- **Purpose:** It stores the processed and formatted output generated by the assembler program. The processed information includes assembly directives, symbols, literals, and operation codes, presented in a readable format.
- **Content:** Contains the processed information derived from `sample.txt`, including assembly directives, symbols, literals, and operation codes. This output is generated according to the logic and rules implemented in the Java code.

### What Happens If These Files Are Not Provided?
- **Input File (`sample.txt`):** If the input file is not provided, the program will have no assembly code to process. Consequently, the program will not perform any operations, and the output file will either remain empty or may not be created at all, depending on the specific implementation of the code.
- **Output File (`Output1.txt`):** If the output file is not provided, the program will execute normally but will not store the processed output. As a result, the processed information will be displayed on the console (standard output) instead of being saved in a file.

In summary, `sample.txt` is crucial as it provides the input assembly code for processing, and `Output1.txt` is essential to store the formatted output. Without these files, the program's functionality will be severely limited, as there will be no input to process, and the output will not be saved for further reference or analysis.




Certainly! Here are some theoretical questions that could be asked during a viva based on the given code along with their answers:

### 1. **Question: What is the purpose of the `spos` class in this code?**
**Answer:** The `spos` class contains the main method and logic for processing the given assembly instructions. It reads input from `sample.txt`, processes the instructions, generates formatted output, and writes the result to `Output1.txt`.

### 2. **Question: Explain the purpose of the `obj` class in the code.**
**Answer:** The `obj` class is a custom data structure used to store symbols, literals, and operation codes. It has two fields: `name` (for the name of the symbol, literal, or mnemonic) and `addr` (for the corresponding address or opcode).

### 3. **Question: How are assembly instructions processed in this code?**
**Answer:** Assembly instructions are read line by line from `sample.txt`. Each line is split into tokens. The code analyzes the tokens to identify assembly directives (`start`, `end`, `origin`, `ltorg`, `equ`), mnemonics, registers, literals, symbols, and constants. Based on the identified components, the code generates formatted output for each line.

### 4. **Question: What is the purpose of the `pooltable` class in the code?**
**Answer:** The `pooltable` class represents pool table entries. It is used to store the starting index (`first`) and the total number of literals (`total_literals`) in a pool. Pool tables keep track of literals that are generated between consecutive `ltorg` statements.

### 5. **Question: How is the symbol table populated in this code?**
**Answer:** Symbols are populated in the symbol table (`symb_table`) when the code encounters labels (e.g., `up:`) or symbols in the assembly code. Each symbol is associated with an address. Symbols are stored in the `symb_table` array along with their corresponding addresses.

### 6. **Question: Explain the purpose of the `ltorg` directive in this code.**
**Answer:** The `ltorg` directive in the assembly code signifies that the literals encountered so far are to be allocated memory addresses. In this code, between two `ltorg` statements, literals are collected, and their addresses are allocated in memory. The corresponding pool table entries are updated, and the literals' addresses are generated and output to `Output1.txt`.

### 7. **Question: How are literals processed and allocated memory addresses?**
**Answer:** Literals are identified based on patterns like `='5'`. When encountered, they are added to the literal table (`literal_table`). Between `ltorg` statements, the code assigns memory addresses to literals, updating their `addr` values. The allocated addresses are then output in the formatted output.

### 8. **Question: What is the significance of the `origin` directive in this code?**
**Answer:** The `origin` directive sets the location counter (`loc`) to a specified value, allowing the program to continue processing from that point onward. It is used to change the program's starting address based on a symbol or a numeric value specified in the assembly code.

### 9. **Question: How are registers and mnemonics processed in this code?**
**Answer:** Registers and mnemonics are identified by matching tokens with predefined arrays (`REG` and `IS`). When a register or mnemonic is found, the corresponding opcode or register index is recorded, and the information is included in the formatted output.

### 10. **Question: Explain the overall flow of the code from reading input to generating output.**
**Answer:** The code reads assembly instructions from `sample.txt` line by line. It processes each line, identifying assembly directives, mnemonics, symbols, literals, and constants. Based on this analysis, it generates formatted output, including assembly directives, symbols, literals, and operation codes. The output is written to `Output1.txt`. Additionally, the code prints the symbol table, pool table, literal table, and operation table on the console for reference.

These questions and answers provide a comprehensive overview of the code's functionality and logic, which can be useful for understanding the program during a viva or discussion.

